내용 정리
CPU내에 존재하는 레지스터들은 현재 실행중인 프로세스 관련 데이터들로 채워진다. 
실행중인 프로세스가 변경이 되면, CPU내 레지스터들의 값이 변경되어야 하는데, 변경되기 전에 이전 프로세스가 지니고 있던 데이터들을 어딘가에 저장해 주어어야 한다.( 이어서 실행하기 위해 ). 그리고 새로 실행되는 프로세스가 아니라면 이전에 실행될 때 레지스터들이 지니고 있던 데이터들을 불러와서 이어서 실행해야 한다. 이 과정이 컨텍스트 스위칭이다. 
실행되는 프로세스의 변경 과정에서 발생하는 컨텍스트 스위칭은 시스템에 많은 부담을 준다.
레지스터 개수가 많을수록, 프로세스별로 관리되어야할 데이터 종류가 많을수록 더 부담이 된다.
컨텍스트 스위칭에 소요되는 시간을 줄이려면 저장하고 복원하는 컨텍스트 정보의 개수를 줄여주면 된다. 

메모리 구조 관점에서 본 프로세스와 쓰레드
: 자식 프로세스가 생성되고 난 다음에는 부모프로세스가 가진 핸들테이블은 상속되지만 모든것(Code/data/heap/stack영역) 이 독립적으로 만들어진다. 이러한 메모리 구조를 지녔기에, 프로세스간에 데이터를 주고받기 위해서는 IPC(Inter Process Communication)가 필요하다.
하지만 쓰레드를 생성하는 경우 메모리 구조는 다르다. 
프로세스가 쓰레드A와 B를 생성한 경우 쓰레드를 생성할 때마다, 해당 쓰레드만을 위한 ThreadStack영역(실행 흐름의 추가를 위한 최소조건)만이 생성될 뿐, 나머지 영역(Code, Data, Heap)은 부모 프로세스 영역을 공유하고 있다. 쓰레드마다 스택을 독립적으로 할당해준다.

각 스위칭 비교
프로세스 컨텍스트 스위칭: 커널 모드 전환, CPU 레지스터 상태 교체(이 과정은 프로그램 카운터, 스택 포인터, 그리고 일반 목적 레지스터 등 모든 중요한 레지스터가 새 작업의 값으로 덮어쓰여지는 것을 포함합니다.), 가상 메모리 주소 처리 필요(프로세스 별로 별도의 메모리를 가짐, 이전껄 다르곳에 저장하고 현재껄 지정해야 함, 단 스택 영역은 공유하지 않음).
스레드 컨텍스트 스위칭: 커널 모드 전환(os가 관리), CPU 레지스터 상태 교체 필요.
코루틴 컨텍스트 스위칭: 사용자 수준에서 이루어지며(이래서 쓰레드보다 비용이 적음, os 관리 수준보다 작업이 적음), CPU 레지스터 상태 교체 필요.

코루틴:
코루틴은 같은 스레드 내에서 실행되므로, 병렬로 실행되지 않습니다. 코루틴 간에는 시간 분할을 통해 논리적 병행성을 제공하지만, 실제로는 하나의 스레드 내에서 순차적으로 실행됩니다.


non blocking 동작: 결국 해당 동작은 다른 쓰레드나 큐에 비동기 동작 던져놓고 현재 동작 수행하는거 그리고 자원 남으면 해당 동작하는거



https://s7won.tistory.com/11
